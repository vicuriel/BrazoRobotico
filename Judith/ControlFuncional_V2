/* SCARA: 2 motores DC con PID + 2 servos controlados por Serial - ESP32

   M1 (q1): DC con encoder
     DIR   = 25
     PWM   = 26  (LEDC canal 0)
     ENC A = 34
     ENC B = 35

   M2 (q2): DC con encoder
     DIR   = 18
     PWM   = 19  (LEDC canal 1)
     ENC A = 32q
     ENC B = 33

   q3: Servo SG90    -> pin 14
   q4: Servo HK15138 -> pin 27

   Serial 115200:
     ?                  -> estado
     z / z1 / z2        -> cero encoders
     s / s1 / s2        -> stop
     m1 <deg>, m2 <deg>, m <d1> <d2>
     q3 <deg>, q4 <deg>
*/

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiClient.h>
#include <ESP32Servo.h>

// ---------------- WIFI -----------------
//const char* ssid = "Flia Jacquet";
//const char* password = "nicolealeli";

const char* ssid = "LAB_JBNACIMIENTO";
const char* password = "L@bJBN#2024";

WiFiServer tcpServer(5000);   // PUERTO TCP REAL
WiFiClient tcpClient;
String tcpBuf = "";

// ===== RELE =====
const int relePin = 22;   // Cambia si necesitás otro pin

// --------- Pines M1 (ESP32) ----------
const int M1_DIR   = 25;
const int M1_PWM   = 26;
const int M1_ENC_A = 34;
const int M1_ENC_B = 35;

// --------- Pines M2 (ESP32) ----------
const int M2_DIR   = 18;
const int M2_PWM   = 19;
const int M2_ENC_A = 32;
const int M2_ENC_B = 33;

// --------- Servos (q3, q4) ----------
const int SERVO_Q3_PIN = 14;
const int SERVO_Q4_PIN = 27;

Servo servoQ3;
Servo servoQ4;
int q3Pos = 0;
int q4Pos = 0;

// ===== PWM (LEDC) =====
const int CH_M1_PWM   = 8;
const int CH_M2_PWM   = 9;
const int PWM_FREQ    = 20000; // 20 kHz
const int PWM_RES_BIT = 8;     // 0..255

// ===== Mecánico / Encoder =====
const float PPR_MOTOR = 11.0f;
const float GEAR_RATIO = 110.0f;
const float CPR = PPR_MOTOR * GEAR_RATIO * 4.0f;

const int SIGN_DIR_M1 = -1;
const int SIGN_DIR_M2 = -1;

// ===== PID =====
float Kp = 0.088f, Ki = 0.156f, Kd = 0.0f;
float Ts = 0.01f;         // 10 ms
const float INTEG_LIM = 150.0f;

const float DEADZONE_DEG = 0.8f;
const int   PWM_MAX = 140;
const int   PWM_MIN = 45;

const int   PWM_STATIC = 18;
const float BOOST_OFF_DEG = 12.0f;

const float ALPHA_PWM = 0.25f;
const float ALPHA_D   = 0.25f;

// ===== Estado M1 =====
volatile long enc1Count = 0;
long   enc1Prev = 0;
float  integ1 = 0.0f;
float  pwmF1 = 0.0f;
float  wFilt1 = 0.0f;

// ===== Estado M2 =====
volatile long enc2Count = 0;
long   enc2Prev = 0;
float  integ2 = 0.0f;
float  pwmF2 = 0.0f;
float  wFilt2 = 0.0f;

// Setpoints
float target1Deg = 0.0f;
float target2Deg = 0.0f;

unsigned long tPrev = 0;

// ===== Utils =====
inline float wrap360(float a){
  while(a >= 360) a -= 360;
  while(a < 0)    a += 360;
  return a;
}

inline float cnt2deg(long c){
  // Ángulo absoluto en grados, puede ser negativo o mayor a 360
  return (float)c * 360.0f / CPR;
}

inline float angErr(float tgt,float act){
  // Error lineal: target - actual (permite -∞..+∞)
  return tgt - act;
}

// ===== ISRs M1 (ENC A/B) =====
// (usamos dos interrupciones como en el UNO, pero ahora con attachInterrupt)
void IRAM_ATTR isr1A(){
  bool a = digitalRead(M1_ENC_A);
  bool b = digitalRead(M1_ENC_B);
  enc1Count += (a == b) ? SIGN_DIR_M1 : -SIGN_DIR_M1;
}

void IRAM_ATTR isr1B(){
  bool a = digitalRead(M1_ENC_A);
  bool b = digitalRead(M1_ENC_B);
  enc1Count += (a != b) ? SIGN_DIR_M1 : -SIGN_DIR_M1;
}

// ===== ISRs M2 (ENC A/B) =====
void IRAM_ATTR isr2A(){
  bool a = digitalRead(M2_ENC_A);
  bool b = digitalRead(M2_ENC_B);
  enc2Count += (a == b) ? SIGN_DIR_M2 : -SIGN_DIR_M2;
}

void IRAM_ATTR isr2B(){
  bool a = digitalRead(M2_ENC_A);
  bool b = digitalRead(M2_ENC_B);
  enc2Count += (a != b) ? SIGN_DIR_M2 : -SIGN_DIR_M2;
}

// ===== Control DC (adaptado a LEDC) =====
void controlUno(long encNow, long &encPrev, float &integ, float &wFilt, float &pwmFiltered,
                int pinDir, int pwmChannel, float targetDeg)
{
  float ang = cnt2deg(encNow);
  float e = angErr(targetDeg, ang);

  long dCounts = encNow - encPrev;
  float w = ((float)dCounts * 360.0f / CPR) / Ts;
  wFilt = ALPHA_D*w + (1.0f-ALPHA_D)*wFilt;

  if (fabs(e) < DEADZONE_DEG){
    integ = 0.0f;
    pwmFiltered = 0.0f;
    ledcWrite(pwmChannel, 0);
  } else {
    // Integral con anti-windup
    integ += Ki*Ts*e;
    if(integ > INTEG_LIM) integ = INTEG_LIM;
    if(integ < -INTEG_LIM) integ = -INTEG_LIM;

    float u = Kp*e + integ - Kd*wFilt;

    // Boost estático
    float boost = 0.0f;
    float ae = fabs(e);
    if(ae > DEADZONE_DEG){
      float k = ae>=BOOST_OFF_DEG?1.0f:(ae-DEADZONE_DEG)/(BOOST_OFF_DEG-DEADZONE_DEG);
      if(k<0) k=0;
      boost = PWM_STATIC*k;
    }

    int pwm = (int)(fabs(u)+boost);
    if(pwm > PWM_MAX) pwm = PWM_MAX;
    if(pwm < PWM_MIN) pwm = PWM_MIN;

    pwmFiltered = ALPHA_PWM*pwm + (1.0f-ALPHA_PWM)*pwmFiltered;

    //digitalWrite(pinDir, (u>=0)?HIGH:LOW);
    //ledcWrite(pwmChannel, (int)pwmFiltered); // 0..255 (8 bits)

    // Dirección según el signo del control (u), como antes
  if (u >= 0) {
      digitalWrite(pinDir, LOW);   // Un sentido
  } else {
      digitalWrite(pinDir, HIGH);    // Sentido contrario
  }

  ledcWrite(pwmChannel, (int)pwmFiltered);


    // --- PWM siempre positivo ---
    ledcWrite(pwmChannel, (int)pwmFiltered);

  }

  encPrev = encNow;
}

// ===== Serial =====
void procesarLinea(const String &s);   // forward

void leerComandos(){
  static String buf="";
  while(Serial.available()){
    char c = Serial.read();
    Serial.print(c);
    if(c=='\r') continue;
    if(c=='\n'){
      buf.trim();
      if(buf.length()) procesarLinea(buf);
      buf="";
    } else buf += c;
  }
}

bool parse2floats(const String &s, float &a, float &b) {
    // Saltar el comando "m"
    int start = s.indexOf(' ');
    if (start < 0) return false;

    // Cortar el string después de "m "
    String rest = s.substring(start + 1);
    rest.trim();

    // Buscar espacio que separa a y b
    int sep = rest.indexOf(' ');
    if (sep < 0) return false;

    // Extraer valores
    a = rest.substring(0, sep).toFloat();
    b = rest.substring(sep + 1).toFloat();
    return true;
}

void procesarLinea(const String &s){

  if(s=="?"){
    Serial.print("M1 ang="); Serial.print(cnt2deg(enc1Count));
    Serial.print(" tgt1="); Serial.print(target1Deg);

    Serial.print(" | M2 ang="); Serial.print(cnt2deg(enc2Count));
    Serial.print(" tgt2="); Serial.print(target2Deg);

    Serial.print(" | q3="); Serial.print(q3Pos);
    Serial.print(" q4="); Serial.println(q4Pos);
    return;
  }

  if(s=="z"){
    noInterrupts(); enc1Count=0; enc2Count=0; interrupts();
    target1Deg=target2Deg=0;
    integ1=integ2=0;
    pwmF1=pwmF2=0;
    Serial.println(">> Cero ambos");
    return;
  }

  if(s=="z1"){
    noInterrupts(); enc1Count=0; interrupts();
    target1Deg=0;
    integ1=pwmF1=0;
    Serial.println(">> Cero M1");
    return;
  }

  if(s=="z2"){
    noInterrupts(); enc2Count=0; interrupts();
    target2Deg=0;
    integ2=pwmF2=0;
    Serial.println(">> Cero M2");
    return;
  }

  if(s=="s"){
    target1Deg = cnt2deg(enc1Count);
    target2Deg = cnt2deg(enc2Count);
    integ1=integ2=0;
    pwmF1=pwmF2=0;
    Serial.println(">> Stop ambos");
    return;
  }

  if(s=="s1"){
    target1Deg=cnt2deg(enc1Count);
    integ1=pwmF1=0;
    Serial.println(">> Stop M1");
    return;
  }

  if(s=="s2"){
    target2Deg=cnt2deg(enc2Count);
    integ2=pwmF2=0;
    Serial.println(">> Stop M2");
    return;
  }

  if(s.startsWith("q1 ")){
    const char* p = s.c_str() + 3;
    //float v = atof(p);  
    //if(v>=0 && v<=360){
      //target1Deg=wrap360(v);
      //Serial.print(">> tgt1="); Serial.println(target1Deg);
      while(*p==' ') p++;
      float v = atof(p);
      if(v < -360.0f || v > 360.0f){
        Serial.println("Valor fuera de rango (-360-360)");
        return;
      }
   else {
      //Serial.println("Valor fuera de rango (0-360)");
      target1Deg = v;
      Serial.print(">> tgt1="); Serial.println(target1Deg);
    }
    return;
  }


  if(s.startsWith("q2 ")){
    const char* p = s.c_str() + 3;
    //float v = atof(p);  
    //if(v>=0 && v<=360){
      //target2Deg=wrap360(v);
      //Serial.print(">> tgt2="); Serial.println(target2Deg);
      while(*p==' ') p++;
      float v = atof(p);
      if(v < -360.0f || v > 360.0f){
        Serial.println("Valor fuera de rango (-360-360)");
        return;
    } else {
      //Serial.println("Valor fuera de rango (0-360)");
      target2Deg = v;
      Serial.print(">> tgt2="); Serial.println(target2Deg);
    }
    return;
  }
  
  if(s.startsWith("m ")){
    float a,b;
    if(parse2floats(s,a,b)){
      //target1Deg=wrap360(a);
      //target2Deg=wrap360(b);
      //Serial.print(">> tgt1="); Serial.print(target1Deg);
      //Serial.print(" tgt2="); Serial.println(target2Deg);
      if (a < -90.0f || a > 90.0f || b < -90.0f || b > 90.0f) {
      Serial.println("Valor fuera de rango (-90 a 90)");
      return;
    }

    target1Deg = a;
    target2Deg = b;

    Serial.print(">> tgt1="); Serial.print(target1Deg);
    Serial.print(" tgt2=");   Serial.println(target2Deg);
    }
    return;
  }

  if(s.startsWith("q3 ")){
    int v = atoi(s.c_str() + 3);
    if(v>=0 && v<=180){
      q3Pos=v;
      servoQ3.write(v);
      Serial.print(">> q3="); Serial.println(v);
    } else {
      Serial.println("Valor fuera de rango (0-180)");
    }
    return;
  }

  if(s.startsWith("q4 ")){
    int v = atoi(s.c_str() + 3);
    if(v>=0 && v<=180){
      q4Pos=v;
      servoQ4.write(v);
      Serial.print(">> q4="); Serial.println(v);
    } else {
      Serial.println("Valor fuera de rango (0-180)");
    }
    return;
  }

  if (s.startsWith("bom")) {
    int v = atoi(s.c_str() + 4);
    if (v == 1) {
        digitalWrite(relePin, HIGH);
        Serial.println(">> RELAY ON");
    }
    else if (v == 0) {
        digitalWrite(relePin, LOW);
        Serial.println(">> RELAY OFF");
    }
    else {
        Serial.println("Valor fuera de rango (0 ó 1)");
    }
    return;
}

  Serial.println("Comando invalido");
  Serial.print(s);
}


// =======================================================
// ===================== SETUP ===========================
// =======================================================

void setup(){
  Serial.begin(115200);

  // --- WIFI ---
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);

  Serial.print("Conectando a WiFi");
  while (WiFi.status() != WL_CONNECTED) {
      delay(500);
      Serial.print(".");
  }
  Serial.println();
  Serial.print("Conectado! IP: ");
  Serial.println(WiFi.localIP());

  // --- TCP SERVER ---
  tcpServer.begin();
  tcpServer.setNoDelay(true);
  Serial.println("TCP server activo en puerto 5000");
  
  // Servos
  servoQ3.attach(SERVO_Q3_PIN);
  servoQ4.attach(SERVO_Q4_PIN);
  delay(100);
  servoQ3.write(0);
  servoQ4.write(0);
  delay(500);

  // Motores
  pinMode(M1_DIR,OUTPUT);
  pinMode(M2_DIR,OUTPUT);

  // PWM por LEDC
  ledcSetup(CH_M1_PWM, PWM_FREQ, PWM_RES_BIT);
  ledcAttachPin(M1_PWM, CH_M1_PWM);
  ledcSetup(CH_M2_PWM, PWM_FREQ, PWM_RES_BIT);
  ledcAttachPin(M2_PWM, CH_M2_PWM);

  digitalWrite(M1_DIR,LOW); ledcWrite(CH_M1_PWM,0);
  digitalWrite(M2_DIR,LOW); ledcWrite(CH_M2_PWM,0);

  // Encoders
  pinMode(M1_ENC_A,INPUT);
  pinMode(M1_ENC_B,INPUT);
  pinMode(M2_ENC_A,INPUT);
  pinMode(M2_ENC_B,INPUT);

  attachInterrupt(M1_ENC_A, isr1A, CHANGE);
  attachInterrupt(M1_ENC_B, isr1B, CHANGE);
  attachInterrupt(M2_ENC_A, isr2A, CHANGE);
  attachInterrupt(M2_ENC_B, isr2B, CHANGE);

  enc1Prev = enc1Count;
  enc2Prev = enc2Count;

  Serial.println("SCARA ESP32 listo.");

  // Rele
  pinMode(relePin, OUTPUT);
  digitalWrite(relePin, LOW);   // Bomba apagada al inicio
}

// =======================================================
// ====================== LOOP ===========================
// =======================================================

void loop(){

  // -------------------- USB SERIAL --------------------
  leerComandos();

  // --- Aceptar cliente TCP ---
  if (!tcpClient.connected()) {
    tcpClient.stop();
    tcpClient = tcpServer.available();
    tcpBuf = "";
  }

  // --- Leer comandos desde TCP ---
  if (tcpClient && tcpClient.connected()) {
    while (tcpClient.available()) {
        char c = tcpClient.read();

        if (c == '\n') {
            tcpBuf.trim();
            if (tcpBuf.length() > 0) procesarLinea(tcpBuf);
            tcpBuf = "";
        }
        else if (c != '\r') {
            tcpBuf += c;
        }
    }
  }


  // -------------------- CONTROL M1/M2 --------------------
  unsigned long tNow = millis();
  if (tNow - tPrev >= (unsigned long)(Ts*1000.0f)) {
    tPrev = tNow;

    // Control M1
    long enc1Now = enc1Count;
    controlUno(enc1Now, enc1Prev, integ1, wFilt1, pwmF1,
               M1_DIR, CH_M1_PWM, target1Deg);

    // Control M2
    long enc2Now = enc2Count;
    controlUno(enc2Now, enc2Prev, integ2, wFilt2, pwmF2,
               M2_DIR, CH_M2_PWM, target2Deg);
  }
}
